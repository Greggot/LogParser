#include "include\Parse.h"

//**************************************************************************************************
// Global variable
//**************************************************************************************************

byteString empbyteString {{0,0,0,0,0,0,0,0}}; //Пустая байт-строка для инициализации байт-строк


//**************************************************************************************************
// Procedure byteStringOut()
//**************************************************************************************************

// Вывод байт-строки в консоль //

void Parser::byteStringOut(byteString Out)
{
    for (uint8_t i = 0; i < STRING_LENGTH_BYTE; i++)
        std::cout << std::hex << (int) Out.bytes[i] << '\t';
    std::cout << std::endl;
}


//**************************************************************************************************
// Procedure StringToByte()
//**************************************************************************************************

// Перевод строки в байт-строку //

byteString Parser::StringToByte(std::string Input)
{
        byteString Output = empbyteString;    //Создаём пустую строку
        
        uint8_t Count = 0;              //Номер байта в строке
        std::string buff = "";          //Буфер с подстрокой, полученной разделением входной табами

        uint8_t cycleLength = Input.size() + 1;         
        for (uint8_t i = 0; i < cycleLength; i++)       
        {
            if (Input[i] == '\t' || Input[i] == '\x0')          //Если встречается табили конец строки
            {
                Output.bytes[Count] = (uint8_t) std::stoi(buff, 0, 16); //Перевести подстроку из буфера в шестнадцатеричное число 
                buff = "";                                              //Очистить буфер
                Count++;
            }
            buff += Input[i];           //Буфер заполняется по одному символу
        }
        return Output;
}

//**************************************************************************************************
// Procedure IsCommand()
//**************************************************************************************************

// Проверка определённого командным индексом байта строки на наличие в нём SID //

bool Parser::IsCommand (byteString Input, CommandIndex cmnd)
{
    return Input.bytes[cmnd.SID] == cmnd.SID_VALUE;
}